<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- Updated viewport meta tag for mobile devices -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Numeric Towers</title>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron&display=swap">
    <style>
        /* General Styles */
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: 'Orbitron', sans-serif;
            background-color: #1a1a2e;
            color: #ffffff;
            overflow: hidden;
        }
        .screen {
            display: none;
            height: 100%;
            width: 100%;
            position: absolute;
            top: 0;
            left: 0;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
        }
        .screen.active {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        .container {
            text-align: center;
            max-width: 600px;
            width: 90%;
        }
        button {
            background: linear-gradient(135deg, #283c86 0%, #45a247 100%);
            border: 2px solid #fff;
            border-radius: 8px;
            color: #fff;
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            text-transform: uppercase;
            text-align: center;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
            padding: 12px 30px;
            margin: 20px auto 0;
            display: block;
            width: 215.15px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        button:hover {
            background: linear-gradient(135deg, #45a247 0%, #283c86 100%);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        #game-title {
            font-size: 2.5em;
            margin-bottom: 30px;
            text-transform: uppercase;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            color: #e94560;
        }
        #game-controls {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background-color: rgba(26, 26, 46, 0.8);
            padding: 10px 0;
            z-index: 101;
            display: none;
            text-align: center;
        }
        #game-controls button {
            display: inline-block;
            width: auto;
            padding: 8px 15px;
            margin: 0 5px;
            font-size: 14px;
        }
        #hud {
            position: fixed;
            top: 50px;
            left: 0;
            width: 100%;
            background-color: rgba(255, 255, 255, 0.9);
            color: #1a1a2e;
            padding: 10px;
            z-index: 100;
            display: none;
            font-family: 'Orbitron', sans-serif;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        #hud span {
            margin: 0 10px;
        }
        #game-container {
            position: relative;
            width: 100%;
            height: calc(100% - 100px);
            overflow: hidden;
            background-color: #0f3460;
            border: 2px solid #e94560;
            box-shadow: 0 0 20px rgba(233, 69, 96, 0.5);
        }
        #game-screen {
            background: none;
        }
        #instructions-screen {
            z-index: 200;
        }
        #instructions-screen.overlay {
            background: rgba(0, 0, 0, 0.8);
        }
        #instructions-screen .container {
            background: #1a1a2e;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(233, 69, 96, 0.5);
        }
        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            background-color: #f0f0f0; /* Added background color for better visibility */
        }
        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: #fff;
            text-shadow: 2px 2px 4px #000;
            z-index: 3;
            display: none;
        }
        @media (max-width: 600px) {
            #game-title {
                font-size: 2em;
            }
            button {
                width: 80%;
                font-size: 16px;
            }
            #game-controls button {
                font-size: 12px;
                padding: 6px 12px;
            }
        }
    </style>
</head>
<body>
    <!-- Game Controls -->
    <div id="game-controls">
        <button id="game-menu-button">Menu</button>
        <button id="game-restart-button">Restart</button>
        <button id="game-instructions-button">Instructions</button>
    </div>

    <!-- Heads-Up Display (HUD) -->
    <div id="hud">
        <span id="score-display">Score: 0</span> | 
        <span id="height-display">Height: 0</span> | 
        <span id="high-score-display">High Score: 0</span>
        <span id="target-height-display"></span>
    </div>

    <!-- Start Menu Screen -->
    <div id="start-menu-screen" class="active screen">
        <div class="container">
            <h1 id="game-title">Number Summit</h1>
            <button id="play-button">Play</button>
            <button id="settings-button">Settings</button>
            <button id="instructions-button">Instructions</button>
        </div>
    </div>

    <!-- Settings Screen -->
    <div id="settings-screen" class="screen">
        <div class="container">
            <h2>Settings</h2>
            <div class="radio-group">
                <p>Game Mode:</p>
                <div class="radio-option">
                    <input type="radio" id="endless-mode" name="game-mode" value="Endless Mode" checked>
                    <label for="endless-mode">Endless Mode</label>
                </div>
                <div class="radio-option">
                    <input type="radio" id="challenge-mode" name="game-mode" value="Challenge Mode">
                    <label for="challenge-mode">Challenge Mode</label>
                </div>
                <p>Stacking Mode:</p>
                <div class="radio-option">
                    <input type="radio" id="ascending-mode" name="stacking-mode" value="Ascending" checked>
                    <label for="ascending-mode">Ascending</label>
                </div>
                <div class="radio-option">
                    <input type="radio" id="descending-mode" name="stacking-mode" value="Descending">
                    <label for="descending-mode">Descending</label>
                </div>
                <p>Select Difficulty Level:</p>
                <div class="radio-option">
                    <input type="radio" id="easy" name="difficulty" value="Easy">
                    <label for="easy">Easy</label>
                </div>
                <div class="radio-option">
                    <input type="radio" id="medium" name="difficulty" value="Medium" checked>
                    <label for="medium">Medium</label>
                </div>
                <div class="radio-option">
                    <input type="radio" id="hard" name="difficulty" value="Hard">
                    <label for="hard">Hard</label>
                </div>
            </div>
            <button id="music-toggle-button">Music On</button>
            <button id="setting-back-button">Back</button>
        </div>
    </div>

    <!-- Instructions Screen -->
    <div id="instructions-screen" class="screen">
        <div class="container">
            <h2>Instructions</h2>
            <p>
                Numeric Towers is a strategic stacking game where you build towers using numbered blocks from 1 to 100.
            </p>
            <p>
                <strong>Objective:</strong><br>
                - In <strong>Endless Mode</strong>, stack as high as possible without collapsing.<br>
                - In <strong>Challenge Mode</strong>, reach a random target height displayed in the HUD.
            </p>
            <p>
                <strong>Stacking Mode:</strong><br>
                - <strong>Ascending:</strong> Stack blocks in increasing numerical order.<br>
                - <strong>Descending:</strong> Stack blocks in decreasing numerical order.
            </p>
            <p>
                <strong>Controls:</strong><br>
                - <strong>Tap Left Side:</strong> Move block left<br>
                - <strong>Tap Right Side:</strong> Move block right<br>
                - <strong>Tap Below Block:</strong> Drop block faster<br>
                - <strong>Spacebar:</strong> Drop block immediately
            </p>
            <p>
                <strong>Obstacles:</strong><br>
                - <strong>Wind Gusts:</strong> Occasional winds that sway the tower.<br>
                - <strong>Earthquakes:</strong> Random shakes that challenge stability.
            </p>
            <p>
                <strong>Power-ups:</strong><br>
                - <strong>Glue Blocks:</strong> Secure a block in place.<br>
                - <strong>Reinforcement Bars:</strong> Add stability to a section.
            </p>
            <button id="instructions-back-button">Back</button>
        </div>
    </div>

    <!-- Game Screen -->
    <div id="game-screen" class="screen">
        <div id="game-container">
            <!-- Responsive canvas without fixed width and height -->
            <canvas id="gameCanvas"></canvas>
            <div id="message"></div>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="screen">
        <div class="container">
            <div id="game-over-message">Game Over!</div>
            <button id="play-again-button">Play Again</button>
            <button id="game-over-main-menu-button" class="main-menu-button">Main Menu</button>
        </div>
    </div>

    <!-- Audio Elements -->
    <audio id="background-music" loop>
        <source src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3" type="audio/mpeg" />
    </audio>
    <audio id="start-game-sound">
        <source src="https://www.soundjay.com/button/sounds/button-3.mp3" type="audio/mpeg" />
    </audio>
    <audio id="end-game-sound">
        <source src="https://www.soundjay.com/button/sounds/button-10.mp3" type="audio/mpeg" />
    </audio>
    <audio id="win-game-sound">
        <source src="https://www.soundjay.com/misc/sounds/bell-ringing-05.mp3" type="audio/mpeg" />
    </audio>
    <audio id="block-placed-sound">
        <source src="https://www.soundjay.com/button/sounds/button-4.mp3" type="audio/mpeg" />
    </audio>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            class GameUI {
                constructor() {
                    // Screen elements
                    this.screens = {
                        startMenu: document.getElementById('start-menu-screen'),
                        settings: document.getElementById('settings-screen'),
                        instructions: document.getElementById('instructions-screen'),
                        game: document.getElementById('game-screen'),
                        gameOver: document.getElementById('game-over-screen')
                    };
                    this.hud = document.getElementById('hud');
                    this.gameControls = document.getElementById('game-controls');
                    this.scoreElement = document.getElementById('score-display');
                    this.heightElement = document.getElementById('height-display');
                    this.highScoreElement = document.getElementById('high-score-display');
                    this.targetHeightElement = document.getElementById('target-height-display');
                    this.messageElement = document.getElementById('message');
                    this.musicToggleButton = document.getElementById('music-toggle-button');
                    this.backgroundMusic = document.getElementById('background-music');
                    this.startGameSound = document.getElementById('start-game-sound');
                    this.endGameSound = document.getElementById('end-game-sound');
                    this.winGameSound = document.getElementById('win-game-sound');
                    this.blockPlacedSound = document.getElementById('block-placed-sound');
                    this.isMusicOn = true;
                    this.gameModeRadios = document.getElementsByName('game-mode');
                    this.stackingModeRadios = document.getElementsByName('stacking-mode');
                    this.difficultyRadios = document.getElementsByName('difficulty');
                    this.gameMode = 'Endless Mode';
                    this.stackingMode = 'Ascending';
                    this.difficulty = 'Medium';
                    this.highScore = 0;
                    this.bindUIActions();
                }

                bindUIActions() {
                    this.musicToggleButton.addEventListener('click', () => {
                        this.toggleMusic();
                    });

                    this.gameModeRadios.forEach(radio => {
                        radio.addEventListener('change', (e) => {
                            this.setGameMode(e.target.value);
                        });
                    });

                    this.stackingModeRadios.forEach(radio => {
                        radio.addEventListener('change', (e) => {
                            this.setStackingMode(e.target.value);
                        });
                    });

                    this.difficultyRadios.forEach(radio => {
                        radio.addEventListener('change', (e) => {
                            this.setDifficulty(e.target.value);
                        });
                    });
                }

                showScreen(screenName) {
                    Object.values(this.screens).forEach(screen => screen.classList.remove('active'));
                    this.screens[screenName].classList.add('active');
                    if (screenName === 'game') {
                        this.hud.style.display = 'block';
                        this.gameControls.style.display = 'block';
                    } else {
                        this.hud.style.display = 'none';
                        this.gameControls.style.display = 'none';
                    }
                }

                startGame() {
                    this.showScreen('game');
                    this.startGameSound.currentTime = 0;
                    this.startGameSound.play();
                    this.playBackgroundMusic();
                }

                endGame(message) {
                    this.showScreen('gameOver');
                    document.getElementById('game-over-message').textContent = message;
                    this.endGameSound.currentTime = 0;
                    this.endGameSound.play();
                    this.stopBackgroundMusic();
                }

                updateScore(score) {
                    this.scoreElement.textContent = 'Score: ' + score;
                    // Update high score if necessary
                    if (score > this.highScore) {
                        this.highScore = score;
                        this.updateHighScore(this.highScore);
                    }
                }

                updateHeight(height) {
                    this.heightElement.textContent = 'Height: ' + Math.round(height);
                }

                updateHighScore(highScore) {
                    this.highScoreElement.textContent = 'High Score: ' + highScore;
                }

                updateTargetHeight(targetHeight) {
                    if (targetHeight > 0) {
                        this.targetHeightElement.textContent = 'Target Height: ' + targetHeight;
                    } else {
                        this.targetHeightElement.textContent = '';
                    }
                }

                playBlockPlacedSound() {
                    this.blockPlacedSound.currentTime = 0;
                    this.blockPlacedSound.play();
                }

                playBackgroundMusic() {
                    this.backgroundMusic.currentTime = 0;
                    if (this.isMusicOn) {
                        this.backgroundMusic.play();
                    }
                }

                stopBackgroundMusic() {
                    this.backgroundMusic.pause();
                }

                toggleMusic() {
                    if (this.isMusicOn) {
                        this.backgroundMusic.pause();
                        this.musicToggleButton.textContent = 'Music Off';
                    } else {
                        this.backgroundMusic.play();
                        this.musicToggleButton.textContent = 'Music On';
                    }
                    this.isMusicOn = !this.isMusicOn;
                }

                setDifficulty(level) {
                    this.difficulty = level;
                }

                setGameMode(mode) {
                    this.gameMode = mode;
                }

                setStackingMode(mode) {
                    this.stackingMode = mode;
                }
            }

            class GameLogic {
                constructor(ui) {
                    this.ui = ui;
                    this.canvas = document.getElementById('gameCanvas');
                    this.ctx = this.canvas.getContext('2d');                    
					this.animationFrameId = null;
                    
					// Add event listener to handle window resize
                    window.addEventListener('resize', this.resizeCanvas.bind(this));

                    this.blocks = [];
                    this.currentBlock = null;
                    this.score = 0;
                    this.towerHeight = 0;
                    this.isGameOver = false;
                    this.isPaused = false;
                    this.gravity = 0.05;
                    this.windForce = 0;
                    this.windTimer = 0;
                    this.earthquakeTimer = 0;
                    this.difficultySettings = {
                        'Easy': { windFrequency: 0.001, earthquakeFrequency: 0.0005 },
                        'Medium': { windFrequency: 0.002, earthquakeFrequency: 0.001 },
                        'Hard': { windFrequency: 0.003, earthquakeFrequency: 0.002 }
                    };
                    this.blockLimit = 10;
                    this.targetHeight = 0;
                    this.generateTargetHeight();
                    this.bindControls();
                    this.spawnBlock();
					
					// Set canvas dimensions to match its displayed size
                    this.resizeCanvas();
					
                    this.animationFrameId = requestAnimationFrame(this.gameLoop.bind(this));
                }

                resizeCanvas() {
                    // Get the displayed size of the canvas (from CSS)
                    const canvasWidth = this.canvas.clientWidth;
                    const canvasHeight = this.canvas.clientHeight;

                    // Get the device pixel ratio, defaulting to 1
                    const dpr = window.devicePixelRatio || 1;

                    // Set the canvas's width and height properties, accounting for the device pixel ratio
                    this.canvas.width = canvasWidth * dpr;
                    this.canvas.height = canvasHeight * dpr;

                    // Reset the transformation matrix to the identity matrix
                    this.ctx.setTransform(1, 0, 0, 1, 0, 0);

                    // Scale the drawing context to account for the device pixel ratio
                    this.ctx.scale(dpr, dpr);

                    // Redraw the game elements
                    this.draw();
                }

                generateTargetHeight() {
                    if (this.ui.gameMode === 'Challenge Mode') {
                        this.targetHeight = Math.floor(Math.random() * 300) + 400;
                        this.ui.updateTargetHeight(this.targetHeight);
                    } else {
                        this.targetHeight = 0;
                        this.ui.updateTargetHeight(0);
                    }
                }

                bindControls() {
                    document.addEventListener('keydown', (e) => {
                        if (!this.currentBlock) return;
                        if (this.isPaused) return;
                        switch (e.key) {
                            case 'ArrowLeft':
                            case 'a':
                            case 'A':
                                this.currentBlock.vx = -5;
                                break;
                            case 'ArrowRight':
                            case 'd':
                            case 'D':
                                this.currentBlock.vx = 5;
                                break;
                            case 'ArrowDown':
                            case 's':
                            case 'S':
                                this.currentBlock.vy = 5;
                                break;
                            case ' ':
                                this.currentBlock.vy = 10;
                                break;
                        }
                    });
                    document.addEventListener('keyup', (e) => {
                        if (!this.currentBlock) return;
                        if (this.isPaused) return;
                        if (['ArrowLeft', 'ArrowRight', 'a', 'A', 'd', 'D'].includes(e.key)) {
                            this.currentBlock.vx = 0;
                        }
                        if (['ArrowDown', 's', 'S', ' '].includes(e.key)) {
                            this.currentBlock.vy = 2;
                        }
                    });

                    // Touch Controls
                    this.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
                }

                handleTouchStart(e) {
                    e.preventDefault();
                    if (!this.currentBlock) return;
                    if (this.isPaused) return;

                    const touch = e.touches[0];
                    const touchX = touch.clientX;
                    const touchY = touch.clientY;

                    const canvasRect = this.canvas.getBoundingClientRect();

                    if (
                        touchX < canvasRect.left ||
                        touchX > canvasRect.right ||
                        touchY < canvasRect.top ||
                        touchY > canvasRect.bottom
                    ) {
                        return;
                    }

                    const blockX = canvasRect.left + (this.currentBlock.x / this.canvas.width) * canvasRect.width;
                    const blockY = canvasRect.top + (this.currentBlock.y / this.canvas.height) * canvasRect.height;

                    if (touchX < blockX - 20) {
                        this.currentBlock.vx = -5;
                    } else if (touchX > blockX + 20) {
                        this.currentBlock.vx = 5;
                    } else if (touchY > blockY + 20) {
                        this.currentBlock.vy = 5;
                    }

                    this.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: false });
                }

                handleTouchEnd(e) {
                    e.preventDefault();
                    if (!this.currentBlock) return;
                    this.currentBlock.vx = 0;
                    this.currentBlock.vy = 2;
                }

                getLuminance(color) {
                    let r = parseInt(color.substr(1, 2), 16) / 255;
                    let g = parseInt(color.substr(3, 2), 16) / 255;
                    let b = parseInt(color.substr(5, 2), 16) / 255;
                    // per ITU-R BT.709
                    let luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;
                    return luminance;
                }

                spawnBlock() {
                    const number = Math.floor(Math.random() * 100) + 1;
                    const randomColor = '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');
                    const dpr = window.devicePixelRatio || 1;
                    const blockWidth = (this.canvas.width / dpr) * 0.15; // 15% of canvas width
                    const blockHeight = blockWidth; // Square block
                    const luminance = this.getLuminance(randomColor);
                    const fontColor = luminance < 0.5 ? '#FFFFFF' : '#000000';
                    const block = {
                        x: (this.canvas.width / dpr) / 2,
                        y: 0,
                        width: blockWidth,
                        height: blockHeight,
                        vx: 0,
                        vy: 2,
                        number: number,
                        color: randomColor,
                        fontColor: fontColor,
                        isPlaced: false
                    };
                    this.currentBlock = block;
                    this.blocks.push(block);
                }

                applyPhysics(block) {
                    block.vy += this.gravity;
                    block.x += block.vx + this.windForce;
                    block.y += block.vy;

                    const dpr = window.devicePixelRatio || 1;
                    const canvasWidth = this.canvas.width / dpr;

                    if (block.x - block.width / 2 < 0) {
                        block.x = block.width / 2;
                        block.vx = 0;
                    }
                    if (block.x + block.width / 2 > canvasWidth) {
                        block.x = canvasWidth - block.width / 2;
                        block.vx = 0;
                    }
                }

                checkCollisions() {
                    if (!this.currentBlock) return;

                    const dpr = window.devicePixelRatio || 1;
                    const canvasHeight = this.canvas.height / dpr;

                    if (this.currentBlock.y + this.currentBlock.height / 2 >= canvasHeight) {
                        this.currentBlock.y = canvasHeight - this.currentBlock.height / 2;
                        this.currentBlock.isPlaced = true;
                        this.placeBlock();
                        return;
                    }

                    for (let i = 0; i < this.blocks.length - 1; i++) {
                        const block = this.blocks[i];
                        if (this.isColliding(this.currentBlock, block)) {
                            if (this.isPlacementValid(block)) {
                                this.currentBlock.y = block.y - block.height / 2 - this.currentBlock.height / 2;
                                this.currentBlock.isPlaced = true;
                                this.placeBlock();
                            } else {
                                this.isGameOver = true;
                                this.ui.endGame('Game Over!');
                            }
                            return;
                        }
                    }
                }

                isColliding(a, b) {
                    return (
                        a.x + a.width / 2 > b.x - b.width / 2 &&
                        a.x - a.width / 2 < b.x + b.width / 2 &&
                        a.y + a.height / 2 > b.y - b.height / 2 &&
                        a.y - a.height / 2 < b.y + b.height / 2
                    );
                }

                isPlacementValid(belowBlock) {
                    if (this.ui.stackingMode === 'Ascending') {
                        return this.currentBlock.number > belowBlock.number;
                    } else {
                        return this.currentBlock.number < belowBlock.number;
                    }
                }

                placeBlock() {
                    this.ui.playBlockPlacedSound();
                    this.score += 10;
                    this.towerHeight = this.calculateMaxTowerHeight();
                    this.ui.updateScore(this.score);
                    this.ui.updateHeight(this.towerHeight);

                    if (this.towerHeight >= (this.canvas.height / (window.devicePixelRatio || 1))) {
                        this.isGameOver = true;
                        this.ui.endGame('You Win!');
                        return;
                    }

                    if (this.ui.gameMode === 'Challenge Mode') {
                        if (this.towerHeight >= this.targetHeight) {
                            this.isGameOver = true;
                            this.ui.endGame('You Win!');
                            return;
                        }
                        if (this.blocks.filter(b => b.isPlaced).length >= this.blockLimit) {
                            this.isGameOver = true;
                            this.ui.endGame('Game Over!');
                            return;
                        }
                    }

                    this.spawnBlock();
                }

                calculateMaxTowerHeight() {
                    let maxHeight = 0;
                    const towers = {};

                    this.blocks.forEach(block => {
                        if (block.isPlaced) {
                            const xKey = Math.floor(block.x / 50);
                            if (!towers[xKey]) {
                                towers[xKey] = [];
                            }
                            towers[xKey].push(block);
                        }
                    });

                    for (let key in towers) {
                        const towerHeight = towers[key].reduce((acc, block) => acc + block.height, 0);
                        if (towerHeight > maxHeight) {
                            maxHeight = towerHeight;
                        }
                    }

                    return maxHeight;
                }

                applyWind() {
                    const difficulty = this.difficultySettings[this.ui.difficulty];
                    if (Math.random() < difficulty.windFrequency) {
                        this.windForce = (Math.random() - 0.5) * 2;
                        this.windTimer = 200;
                    }
                    if (this.windTimer > 0) {
                        this.windTimer--;
                    } else {
                        this.windForce = 0;
                    }
                }

                applyEarthquake() {
                    const difficulty = this.difficultySettings[this.ui.difficulty];
                    if (Math.random() < difficulty.earthquakeFrequency) {
                        this.earthquakeTimer = 100;
                    }
                    if (this.earthquakeTimer > 0) {
                        this.earthquakeTimer--;
                        this.blocks.forEach(block => {
                            block.x += (Math.random() - 0.5) * 5;
                        });
                    }
                }

                update() {
                    if (this.isGameOver) return;
                    if (this.isPaused) return;
                    this.applyWind();
                    this.applyEarthquake();
                    if (this.currentBlock && !this.currentBlock.isPlaced) {
                        this.applyPhysics(this.currentBlock);
                        this.checkCollisions();
                    }
                }

                draw() {
                    // Clear the canvas
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    // Draw each block
                    this.blocks.forEach(block => {
                        this.ctx.fillStyle = block.color;
                        this.ctx.fillRect(
                            block.x - block.width / 2,
                            block.y - block.height / 2,
                            block.width,
                            block.height
                        );
                        this.ctx.fillStyle = block.fontColor;
                        const fontSize = block.height * 0.6; // Adjusted font size based on block height
                        this.ctx.font = 'bold ' + fontSize + 'px Arial';
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'middle'; // Center text vertically
                        this.ctx.fillText(
                            block.number,
                            block.x,
                            block.y
                        );
                    });
                }

                gameLoop() {
                    if (this.isGameOver) return;
                    if (this.isPaused) return;
                    this.update();
                    this.draw();
					
					if (this.animationFrameId) {
						cancelAnimationFrame(this.animationFrameId);
					}
                    this.animationFrameId = requestAnimationFrame(this.gameLoop.bind(this));
                }

                resetGame() {
                    this.blocks = [];
                    this.currentBlock = null;
                    this.isGameOver = false;
                    this.isPaused = false;
                    this.score = 0;
                    this.towerHeight = 0;
                    this.gravity = 0.05; // Reset gravity
                    this.windForce = 0;
                    this.windTimer = 0;
                    this.earthquakeTimer = 0;
                    this.ui.updateScore(0);
                    this.ui.updateHeight(0);
                    this.generateTargetHeight();
                    this.spawnBlock();
					
					if (this.animationFrameId) {
						cancelAnimationFrame(this.animationFrameId);
					}
                    this.animationFrameId = requestAnimationFrame(this.gameLoop.bind(this));
                }
            }

            class Game {
                constructor() {
                    this.ui = new GameUI();
                    this.logic = null;
                    this.assignButtons();
                }

                startGame() {
                    this.ui.startGame();
                    if (this.logic) {
                        this.logic.resetGame();
                    } else {
                        this.logic = new GameLogic(this.ui);
                    }
                }

                resetGame() {
                    if (this.logic) {
                        this.logic.resetGame();
                    }
                }

                assignButtons() {
                    document.getElementById('play-button').addEventListener('click', this.startGame.bind(this));
                    document.getElementById('settings-button').addEventListener('click', () => this.ui.showScreen('settings'));
                    document.getElementById('instructions-button').addEventListener('click', () => this.ui.showScreen('instructions'));
                    document.getElementById('setting-back-button').addEventListener('click', () => this.ui.showScreen('startMenu'));
                    document.getElementById('instructions-back-button').addEventListener('click', () => {
                        if (this.logic && this.logic.isPaused) {
                            this.ui.showScreen('game');
                            this.logic.isPaused = false;
                            requestAnimationFrame(this.logic.gameLoop.bind(this.logic));
                        } else {
                            this.ui.showScreen('startMenu');
                        }
                    });
                    document.getElementById('play-again-button').addEventListener('click', this.startGame.bind(this));
                    document.getElementById('game-over-main-menu-button').addEventListener('click', () => this.ui.showScreen('startMenu'));
                    document.getElementById('game-menu-button').addEventListener('click', () => {
                        if (this.logic) {
                            this.logic.isGameOver = true;
                        }
                        this.ui.showScreen('startMenu');
                    });
                    document.getElementById('game-restart-button').addEventListener('click', this.startGame.bind(this));
                    document.getElementById('game-instructions-button').addEventListener('click', () => {
                        if (this.logic) {
                            this.logic.isPaused = true;
                        }
                        this.ui.showScreen('instructions');
                    });
                }
            }

            const game = new Game();
        });
    </script>
</body>
</html>
